"""
STL generation module for AMS layer generation.

This module converts layer generation results into print-ready STL files,
with one STL file per filament containing all parts for that filament across all layers.
"""

import numpy as np
import os
from typing import List, Dict, Tuple, Any
import struct


def write_binary_stl(filename: str, vertices: np.ndarray, faces: np.ndarray):
    """
    Write a binary STL file.
    
    Args:
        filename: Output STL filename
        vertices: Array of vertices (N, 3)
        faces: Array of face indices (M, 3)
    """
    with open(filename, 'wb') as f:
        # Write 80-byte header
        header_text = b'STL generated by AMS Layer Generator'
        header = header_text + b'\x00' * (80 - len(header_text))
        f.write(header)
        
        # Write number of triangles
        num_triangles = len(faces)
        f.write(struct.pack('<I', num_triangles))
        
        # Write triangles
        for face in faces:
            # Get the three vertices of the triangle
            v0, v1, v2 = vertices[face]
            
            # Calculate normal vector
            edge1 = v1 - v0
            edge2 = v2 - v0
            normal = np.cross(edge1, edge2)
            normal_length = np.linalg.norm(normal)
            if normal_length > 0:
                normal = normal / normal_length
            else:
                normal = np.array([0.0, 0.0, 1.0])
            
            # Write normal vector (3 floats)
            f.write(struct.pack('<fff', normal[0], normal[1], normal[2]))
            
            # Write vertices (9 floats)
            f.write(struct.pack('<fff', v0[0], v0[1], v0[2]))
            f.write(struct.pack('<fff', v1[0], v1[1], v1[2]))
            f.write(struct.pack('<fff', v2[0], v2[1], v2[2]))
            
            # Write attribute byte count (2 bytes, usually 0)
            f.write(struct.pack('<H', 0))


def create_box_mesh(x_min: float, y_min: float, z_min: float,
                   x_max: float, y_max: float, z_max: float) -> Tuple[np.ndarray, np.ndarray]:
    """
    Create a box mesh with given bounds.
    
    Returns:
        Tuple of (vertices, faces) arrays
    """
    # Define 8 vertices of a box
    vertices = np.array([
        [x_min, y_min, z_min],  # 0: bottom-left-front
        [x_max, y_min, z_min],  # 1: bottom-right-front
        [x_max, y_max, z_min],  # 2: bottom-right-back
        [x_min, y_max, z_min],  # 3: bottom-left-back
        [x_min, y_min, z_max],  # 4: top-left-front
        [x_max, y_min, z_max],  # 5: top-right-front
        [x_max, y_max, z_max],  # 6: top-right-back
        [x_min, y_max, z_max],  # 7: top-left-back
    ], dtype=np.float32)
    
    # Define 12 triangular faces (2 triangles per face of the cube)
    faces = np.array([
        # Bottom face (z = z_min)
        [0, 1, 2], [0, 2, 3],
        # Top face (z = z_max)
        [4, 7, 6], [4, 6, 5],
        # Front face (y = y_min)
        [0, 4, 5], [0, 5, 1],
        # Back face (y = y_max)
        [2, 6, 7], [2, 7, 3],
        # Left face (x = x_min)
        [0, 3, 7], [0, 7, 4],
        # Right face (x = x_max)
        [1, 5, 6], [1, 6, 2],
    ], dtype=np.int32)
    
    return vertices, faces


def pixel_to_world_coordinates(pixel_x: int, pixel_y: int, layer_z: float,
                              image_width: int, image_height: int,
                              max_size: float, line_width: float) -> Tuple[float, float, float]:
    """
    Convert pixel coordinates to world coordinates.
    
    Args:
        pixel_x, pixel_y: Pixel coordinates
        layer_z: Z coordinate (layer height)
        image_width, image_height: Image dimensions in pixels
        max_size: Maximum size of the longer side in mm
        line_width: Minimum line width in mm
        
    Returns:
        World coordinates (x, y, z) in mm
    """
    # Calculate scale factor based on max_size and longer side
    longer_side = max(image_width, image_height)
    base_scale = max_size / longer_side
    
    # Use the scale that respects line width but doesn't exceed max_size
    # If line_width forces larger pixels, we need to warn and use max_size constraint
    if line_width > base_scale:
        print(f"Warning: line_width ({line_width}mm) forces pixels larger than max_size constraint")
        print(f"Using pixel size of {base_scale:.3f}mm to respect max_size={max_size}mm")
        effective_scale = base_scale
    else:
        effective_scale = max(base_scale, line_width)
    
    # Convert to world coordinates (center the image)
    world_x = (pixel_x - image_width / 2) * effective_scale
    world_y = (pixel_y - image_height / 2) * effective_scale
    
    return world_x, world_y, layer_z


def generate_dither_pattern_physical(width_mm: float, height_mm: float, 
                                   line_width: float, ratio: float, 
                                   pattern_type: str = 'horizontal') -> List[Tuple[float, float, float, float]]:
    """
    Generate dither pattern in physical coordinates (mm) respecting minimum line width.
    
    Args:
        width_mm, height_mm: Pattern dimensions in mm
        line_width: Minimum line width in mm
        ratio: Fraction of area that should be covered (0.0 to 1.0)
        pattern_type: 'horizontal' or 'vertical'
    
    Returns:
        List of rectangles (x_min, y_min, x_max, y_max) in mm
    """
    rectangles = []
    
    if ratio <= 0:
        return rectangles
    if ratio >= 1:
        return [(0, 0, width_mm, height_mm)]
    
    if pattern_type == 'horizontal':
        # Horizontal line pattern
        # Calculate line spacing to achieve desired ratio
        line_spacing = line_width / ratio
        
        y = 0
        while y < height_mm:
            if y + line_width <= height_mm:
                rectangles.append((0, y, width_mm, y + line_width))
            y += line_spacing
    
    elif pattern_type == 'vertical':
        # Vertical line pattern
        line_spacing = line_width / ratio
        
        x = 0
        while x < width_mm:
            if x + line_width <= width_mm:
                rectangles.append((x, 0, x + line_width, height_mm))
            x += line_spacing
    
    return rectangles


def create_base_layer_mesh(image_width: int, image_height: int,
                          max_size: float, line_width: float,
                          z_min: float, z_max: float) -> Tuple[np.ndarray, np.ndarray]:
    """
    Create a rectangular base layer mesh covering the entire image area.
    
    Args:
        image_width, image_height: Image dimensions in pixels
        max_size: Maximum size of the longer side in mm
        line_width: Minimum line width in mm
        z_min, z_max: Z-coordinates for the base layer
    
    Returns:
        Tuple of (vertices, faces) for the base layer mesh
    """
    # Calculate scale factor - ensure max_size is respected  
    longer_side = max(image_width, image_height)
    base_pixel_size = max_size / longer_side
    
    # Check if line_width forces larger pixels than max_size allows
    if line_width > base_pixel_size:
        print(f"Warning: line_width ({line_width}mm) conflicts with max_size constraint")
        print(f"Using pixel size of {base_pixel_size:.3f}mm to respect max_size={max_size}mm")
        pixel_size = base_pixel_size
    else:
        pixel_size = max(base_pixel_size, line_width)
    
    # Calculate actual print dimensions
    actual_width = image_width * pixel_size
    actual_height = image_height * pixel_size
    
    # Center the base layer
    x_min = -actual_width / 2
    x_max = actual_width / 2
    y_min = -actual_height / 2
    y_max = actual_height / 2
    
    # Create a single large box for the base
    vertices, faces = create_box_mesh(x_min, y_min, z_min, x_max, y_max, z_max)
    
    return vertices, faces


def create_combined_mesh_for_filament(layers: List[Dict[str, List[Tuple[int, int]]]], 
                                    dither_info: Dict,
                                    filament_name: str,
                                    image_width: int, image_height: int,
                                    max_size: float, line_width: float,
                                    layer_height: float,
                                    base_layers: int = 0,
                                    base_filament: str = 'white') -> Tuple[np.ndarray, np.ndarray]:
    """
    Create a combined mesh for all parts of a specific filament across all layers.
    
    Args:
        layers: Layer assignments for each filament
        dither_info: Dithering information
        filament_name: Name of the filament to generate mesh for
        image_width, image_height: Image dimensions in pixels
        max_size: Maximum size of the longer side in mm
        line_width: Minimum line width in mm
        layer_height: Height of each layer in mm
        base_layers: Number of base layers (0 = no base)
        base_filament: Filament to use for base layers
    
    Returns:
        Tuple of (vertices, faces) for the combined mesh
    """
    all_vertices = []
    all_faces = []
    vertex_offset = 0
    
    # Calculate scale factor - ensure max_size is respected
    longer_side = max(image_width, image_height)
    base_pixel_size = max_size / longer_side
    
    # Check if line_width forces larger pixels than max_size allows
    if line_width > base_pixel_size:
        print(f"Warning: line_width ({line_width}mm) conflicts with max_size constraint")
        print(f"Using pixel size of {base_pixel_size:.3f}mm to respect max_size={max_size}mm")
        pixel_size = base_pixel_size
    else:
        pixel_size = max(base_pixel_size, line_width)
    
    # Add base layers if this filament is the base filament
    if base_layers > 0 and filament_name == base_filament:
        for base_layer_idx in range(base_layers):
            z_min = -base_layers * layer_height + base_layer_idx * layer_height
            z_max = z_min + layer_height
            
            vertices, faces = create_base_layer_mesh(
                image_width, image_height, max_size, line_width, z_min, z_max
            )
            
            # Add to combined mesh
            all_vertices.append(vertices)
            all_faces.append(faces + vertex_offset)
            vertex_offset += len(vertices)
    
    # Process regular layer assignments (offset Z by base layer height)
    z_offset = 0  # Base layers are at negative Z, so image layers start at Z=0
    # Process regular layer assignments (offset Z by base layer height)
    z_offset = 0  # Base layers are at negative Z, so image layers start at Z=0
    
    for layer_idx, layer_assignment in enumerate(layers):
        if filament_name in layer_assignment:
            z_min = z_offset + layer_idx * layer_height
            z_max = z_min + layer_height
            
            # Create boxes for regular pixels
            for pixel_x, pixel_y in layer_assignment[filament_name]:
                world_x, world_y, _ = pixel_to_world_coordinates(
                    pixel_x, pixel_y, z_min, image_width, image_height, max_size, line_width
                )
                
                # Create a box for this pixel
                x_min = world_x - pixel_size / 2
                x_max = world_x + pixel_size / 2
                y_min = world_y - pixel_size / 2
                y_max = world_y + pixel_size / 2
                
                vertices, faces = create_box_mesh(x_min, y_min, z_min, x_max, y_max, z_max)
                
                # Add to combined mesh
                all_vertices.append(vertices)
                all_faces.append(faces + vertex_offset)
                vertex_offset += len(vertices)
    
    # Process dithered pixels for this filament
    dithered_pixels_by_layer = {}
    for pixel_key, pixel_info in dither_info.items():
        if pixel_info['filament'] == filament_name:
            layer_idx = pixel_info['layer']
            if layer_idx not in dithered_pixels_by_layer:
                dithered_pixels_by_layer[layer_idx] = []
            
            x, y = map(int, pixel_key.split(','))
            dithered_pixels_by_layer[layer_idx].append({
                'x': x, 'y': y,
                'ratio': pixel_info['ratio'],
                'pattern': pixel_info['pattern']
            })
    
    # Generate physical dither patterns for each layer
    for layer_idx, dithered_pixels in dithered_pixels_by_layer.items():
        z_min = z_offset + layer_idx * layer_height
        z_max = z_min + layer_height
        
        # Group by pattern type and ratio for efficiency
        pattern_groups = {}
        for pixel_info in dithered_pixels:
            key = (pixel_info['pattern'], pixel_info['ratio'])
            if key not in pattern_groups:
                pattern_groups[key] = []
            pattern_groups[key].append((pixel_info['x'], pixel_info['y']))
        
        # Generate dither patterns for each group
        for (pattern_type, ratio), pixel_coords in pattern_groups.items():
            for pixel_x, pixel_y in pixel_coords:
                world_x, world_y, _ = pixel_to_world_coordinates(
                    pixel_x, pixel_y, z_min, image_width, image_height, max_size, line_width
                )
                
                # Generate dither rectangles for this pixel area
                dither_rects = generate_dither_pattern_physical(
                    pixel_size, pixel_size, line_width, ratio, pattern_type
                )
                
                # Create boxes for each dither rectangle
                for rect_x_min, rect_y_min, rect_x_max, rect_y_max in dither_rects:
                    # Translate to pixel position
                    x_min = world_x - pixel_size / 2 + rect_x_min
                    x_max = world_x - pixel_size / 2 + rect_x_max
                    y_min = world_y - pixel_size / 2 + rect_y_min
                    y_max = world_y - pixel_size / 2 + rect_y_max
                    
                    vertices, faces = create_box_mesh(x_min, y_min, z_min, x_max, y_max, z_max)
                    
                    # Add to combined mesh
                    all_vertices.append(vertices)
                    all_faces.append(faces + vertex_offset)
                    vertex_offset += len(vertices)
    
    # Combine all vertices and faces
    if all_vertices:
        combined_vertices = np.vstack(all_vertices)
        combined_faces = np.vstack(all_faces)
        return combined_vertices, combined_faces
    else:
        # Return empty mesh if no geometry
        return np.array([]), np.array([])


def generate_stl_files(layers: List[Dict[str, List[Tuple[int, int]]]], 
                      dither_info: Dict,
                      available_filaments: Dict[str, Dict[str, Any]],
                      image_width: int, image_height: int,
                      max_size: float = 100.0,  # mm
                      line_width: float = 0.4,  # mm
                      layer_height: float = 0.2,  # mm
                      base_layers: int = 1,  # Number of base layers
                      base_filament: str = 'white',  # Filament for base layers
                      output_dir: str = "output") -> Dict[str, str]:
    """
    Generate STL files for 3D printing, one file per filament.
    
    Args:
        layers: Layer assignments for each filament
        dither_info: Dithering information
        available_filaments: Dict of filament properties
        image_width, image_height: Image dimensions in pixels
        max_size: Maximum size of the longer side in mm
        line_width: Minimum line width in mm
        layer_height: Height of each layer in mm
        base_layers: Number of solid base layers (0 = no base)
        base_filament: Filament to use for base layers
        output_dir: Output directory for STL files
    
    Returns:
        Dict mapping filament names to generated STL file paths
    """
    # Create output directory
    os.makedirs(output_dir, exist_ok=True)
    
    generated_files = {}
    
    # Find all filaments that are actually used
    used_filaments = set()
    
    # Check layer assignments
    for layer_assignment in layers:
        used_filaments.update(layer_assignment.keys())
    
    # Check dithering
    for pixel_info in dither_info.values():
        used_filaments.add(pixel_info['filament'])
    
    print(f"Generating STL files for {len(used_filaments)} filaments...")
    print(f"Physical dimensions: {max_size}mm max size, {line_width}mm line width, {layer_height}mm layer height")
    if base_layers > 0:
        print(f"Base layers: {base_layers} layers using {base_filament} filament")
    
    # Generate STL file for each used filament
    for filament_name in used_filaments:
        if filament_name not in available_filaments:
            print(f"Warning: Filament '{filament_name}' not found in available_filaments, skipping...")
            continue
        
        print(f"Generating mesh for {filament_name}...")
        
        # Create combined mesh for this filament
        vertices, faces = create_combined_mesh_for_filament(
            layers, dither_info, filament_name,
            image_width, image_height, max_size, line_width, layer_height,
            base_layers, base_filament
        )
        
        if len(vertices) == 0:
            print(f"  No geometry for {filament_name}, skipping...")
            continue
        
        # Generate filename
        color = available_filaments[filament_name]['color']
        filename = f"{filament_name}_RGB{color[0]}-{color[1]}-{color[2]}.stl"
        filepath = os.path.join(output_dir, filename)
        
        # Write STL file
        write_binary_stl(filepath, vertices, faces)
        generated_files[filament_name] = filepath
        
        print(f"  Generated {filename} with {len(faces)} triangles ({len(vertices)} vertices)")
    
    print(f"\nSTL generation complete! Files saved to '{output_dir}':")
    for filament_name, filepath in generated_files.items():
        file_size = os.path.getsize(filepath) / 1024  # KB
        print(f"  {os.path.basename(filepath)} ({file_size:.1f} KB)")
    
    return generated_files


def estimate_print_stats(layers: List[Dict[str, List[Tuple[int, int]]]], 
                        dither_info: Dict,
                        image_width: int, image_height: int,
                        max_size: float, line_width: float, layer_height: float,
                        base_layers: int = 0, base_filament: str = "white") -> Dict[str, Any]:
    """
    Estimate print statistics like volume, print time estimates, etc.
    
    Args:
        layers: List of layer dictionaries with filament assignments
        dither_info: Dictionary with dithering information
        image_width: Width of original image in pixels
        image_height: Height of original image in pixels
        max_size: Maximum size of model in mm
        line_width: Width of printed lines in mm
        layer_height: Height of each layer in mm
        base_layers: Number of base layers to add (default: 0)
        base_filament: Name of filament for base layers (default: "white")
    
    Returns:
        Dict with print statistics
    """
    # Calculate total volume per filament
    longer_side = max(image_width, image_height)
    pixel_size = max(max_size / longer_side, line_width)
    pixel_volume = pixel_size * pixel_size * layer_height
    
    filament_stats = {}
    
    # Count regular pixels
    for layer_idx, layer_assignment in enumerate(layers):
        for filament_name, positions in layer_assignment.items():
            if filament_name not in filament_stats:
                filament_stats[filament_name] = {'pixels': 0, 'dithered_pixels': 0, 'volume_mm3': 0}
            filament_stats[filament_name]['pixels'] += len(positions)
            filament_stats[filament_name]['volume_mm3'] += len(positions) * pixel_volume
    
    # Count dithered pixels (these are additional volume)
    for pixel_info in dither_info.values():
        filament_name = pixel_info['filament']
        ratio = pixel_info['ratio']
        if filament_name not in filament_stats:
            filament_stats[filament_name] = {'pixels': 0, 'dithered_pixels': 0, 'volume_mm3': 0}
        filament_stats[filament_name]['dithered_pixels'] += 1
        # Dithered volume is proportional to the ratio
        filament_stats[filament_name]['volume_mm3'] += pixel_volume * ratio
    
    # Add base layer statistics
    if base_layers > 0:
        # Calculate base layer volume
        scale = max_size / max(image_width, image_height)
        physical_width = image_width * scale
        physical_height = image_height * scale
        base_area = physical_width * physical_height
        base_volume_per_layer = base_area * layer_height
        total_base_volume = base_volume_per_layer * base_layers
        
        # Add to filament stats
        if base_filament not in filament_stats:
            filament_stats[base_filament] = {'pixels': 0, 'dithered_pixels': 0, 'volume_mm3': 0}
        filament_stats[base_filament]['volume_mm3'] += total_base_volume
    
    # Calculate totals
    total_volume = sum(stats['volume_mm3'] for stats in filament_stats.values())
    total_pixels = sum(stats['pixels'] + stats['dithered_pixels'] for stats in filament_stats.values())
    
    return {
        'filament_stats': filament_stats,
        'total_volume_mm3': total_volume,
        'total_pixels': total_pixels,
        'pixel_size_mm': pixel_size,
        'max_size_mm': max_size,
        'line_width_mm': line_width,
        'layer_height_mm': layer_height,
        'estimated_layers': len(layers),
        'base_layers': base_layers,
        'total_layers': len(layers) + base_layers
    }
